<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Database on Just my blog</title>
    <link>http://iryndin.net/tags/database/index.xml</link>
    <description>Recent content in Database on Just my blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://iryndin.net/tags/database/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Optimistic and pessimistic concurrency control</title>
      <link>http://iryndin.net/post/optimistic_and_pessimistic_concurrency_control/</link>
      <pubDate>Mon, 04 Dec 2017 16:14:52 +0300</pubDate>
      
      <guid>http://iryndin.net/post/optimistic_and_pessimistic_concurrency_control/</guid>
      <description>&lt;p&gt;Here we consider two most widely used approaches to transactional locking: pessimistic and optimistic locking.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Transactional isolation is usually implemented by locking whatever is accessed in a transaction.
There are two different approaches to transactional locking:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pessimistic locking&lt;/li&gt;
&lt;li&gt;Optimistic locking&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;pessimistic-concurrency-control-locking&#34;&gt;Pessimistic concurrency control (locking)&lt;/h2&gt;

&lt;p&gt;Pessimistic locking is called &amp;ldquo;pessimistic&amp;rdquo; because the system assumes the worst —
it assumes that two or more users will want to update the same record at the same time,
and then prevents that possibility by locking the record, no matter how unlikely conflicts actually are.&lt;/p&gt;

&lt;p&gt;Pessimistic locking assumes that data will be changed by another transaction and so locks it.
Pessimistic locking locks the records as soon as it selects rows to update.
The pessimistic locking strategy guarantees the changes are made safely and consistently.&lt;/p&gt;

&lt;p&gt;The disadvantage of pessimistic locking is that a resource is locked from the time it is first accessed in a transaction
until the transaction is finished, making it inaccessible to other transactions during that time.
If most transactions simply look at the resource and never change it, an exclusive lock may be overkill
as it may cause lock contention, and optimistic locking may be a better approach.&lt;/p&gt;

&lt;h2 id=&#34;optimistic-concurrency-control-locking&#34;&gt;Optimistic concurrency control (locking)&lt;/h2&gt;

&lt;p&gt;Optimistic locking assumes that although conflicts are possible, they will be very rare.
Instead of locking every record every time that it is used, the system merely looks for indications
that two users actually did try to update the same record at the same time.&lt;/p&gt;

&lt;p&gt;Optimistic locking locks the record only when updating takes place.
It ensures that the locks are held between selecting, updating, or deleting rows.
This process needs a way to ensure that the changes to data are not performed between the time of being read and being altered.
This is achieved using version numbers, timestamps, hashing, etc.&lt;/p&gt;

&lt;p&gt;The primary advantage of optimistic locking is , it minimizes the time for which a given resource is unavailable
which is used by another transaction and in this way it more scalable locking alternative.&lt;/p&gt;

&lt;h2 id=&#34;what-to-use-optimistic-or-pessimistic-concurrency-control&#34;&gt;What to use - optimistic or pessimistic concurrency control?&lt;/h2&gt;

&lt;p&gt;In most scenarios, optimistic concurrency control is more efficient and offers higher performance.
When choosing between pessimistic and optimistic locking, consider the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pessimistic locking is useful if there are a lot of updates and relatively high chances of users trying to update data at the same time.&lt;/li&gt;
&lt;li&gt;Pessimistic concurrency control is also more appropriate in applications that contain small tables that are frequently updated.&lt;/li&gt;
&lt;li&gt;Optimistic locking is useful if the possibility for conflicts is very low – there are many records but relatively few users, or very few updates and mostly read-type operations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, there is no correct answer – it depends. You should pick your locking scheme based on your application requirements.&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Optimistic_concurrency_control&#34;&gt;Wikipedia - Optimistic concurrency control&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/support/knowledgecenter/en/SSPK3V_7.0.0/com.ibm.swg.im.soliddb.sql.doc/doc/pessimistic.vs.optimistic.concurrency.control.html&#34;&gt;IBM SolidDB Guide - PESSIMISTIC vs. OPTIMISTIC concurrency control&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.objectdb.com/java/jpa/persistence/lock&#34;&gt;ObjectDB Manual - Locking in JPA&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PostgreSQL transaction isolation levels</title>
      <link>http://iryndin.net/post/postgresql_transaction_isolation_levels/</link>
      <pubDate>Tue, 28 Nov 2017 09:59:58 +0300</pubDate>
      
      <guid>http://iryndin.net/post/postgresql_transaction_isolation_levels/</guid>
      <description>&lt;p&gt;Details of transaction isolation in PostgreSQL.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;On previous post &lt;a href=&#34;http://iryndin.net/post/transaction_isolation_levels/&#34;&gt;about transaction isolation levels&lt;/a&gt; we considered what is
transaction isolation level and how this influence the result we get from transaction. But from database to database
details are diferent, so let&amp;rsquo;s consider transaction isolation details for PostgreSQL.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s again repeat a little bit about transaction islolation level.
The SQL standard defines four levels of transaction isolation.
The most strict is &lt;code&gt;Serializable&lt;/code&gt;, which is defined by the standard in a paragraph which says
that any concurrent execution of a set of &lt;code&gt;Serializable&lt;/code&gt; transactions is guaranteed to produce the same effect
as running them one at a time in some order.&lt;/p&gt;

&lt;p&gt;The other three levels are defined in terms of phenomena, resulting from interaction between concurrent transactions, which must not occur at each level.&lt;/p&gt;

&lt;p&gt;The phenomena which are prohibited at various levels are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dirty read&lt;/strong&gt; - A transaction reads data written by a concurrent uncommitted transaction.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nonrepeatable read&lt;/strong&gt; - A transaction re-reads data it has previously read and finds that data has been modified by another transaction (that committed since the initial read).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;phantom read&lt;/strong&gt; - A transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows satisfying the condition has changed due to another recently-committed transaction.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;only-3-isolation-level-internally&#34;&gt;Only 3 isolation level internally&lt;/h2&gt;

&lt;p&gt;Internally, there are only three distinct isolation levels, which correspond to the levels &lt;code&gt;Read Committed&lt;/code&gt;,
&lt;code&gt;Repeatable Read&lt;/code&gt;, and &lt;code&gt;Serializable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When you select the level &lt;code&gt;Read Uncommitted&lt;/code&gt; you really get &lt;code&gt;Read Committed&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Phantom reads&lt;/code&gt; are not possible in the PostgreSQL implementation of &lt;code&gt;Repeatable Read&lt;/code&gt;, so the actual isolation level might be stricter than what you select.
This is permitted by the SQL standard: the four isolation levels only define which phenomena must not happen, they do not define which phenomena must happen.&lt;/p&gt;

&lt;p&gt;The reason that PostgreSQL only provides three isolation levels is that this is the only sensible way to map the standard isolation levels
to the MVCC architecture.&lt;/p&gt;

&lt;h2 id=&#34;read-commited-default&#34;&gt;Read commited (default)&lt;/h2&gt;

&lt;p&gt;A &lt;code&gt;SELECT&lt;/code&gt; query (without a &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; clause) sees only data &lt;strong&gt;committed before the query (not transaction!!) began&lt;/strong&gt;;
it never sees either uncommitted data or changes committed during query execution by concurrent transactions.
In effect, a SELECT query sees a snapshot of the database &lt;strong&gt;as of the instant the query (not transaction!!) begins to run&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;However, &lt;code&gt;SELECT&lt;/code&gt; does see the effects of previous updates executed within its own transaction, even though they are not yet committed.
Also note that two successive &lt;code&gt;SELECT&lt;/code&gt; commands &lt;strong&gt;can see different data&lt;/strong&gt;, even though they are within a single transaction,
if other transactions commit changes during execution of the first &lt;code&gt;SELECT&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;repeatable-read&#34;&gt;Repeatable read&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Repeatable Read&lt;/code&gt; isolation level only sees data &lt;strong&gt;committed before the transaction began&lt;/strong&gt;. This is the difference wit hprevious level -
&lt;code&gt;Read commited&lt;/code&gt; which sees data &lt;strong&gt;before query began&lt;/strong&gt;.
Thus, successive &lt;code&gt;SELECT&lt;/code&gt; commands within a single transaction see the same data, i.e.,
they do not see changes made by other transactions that committed after their own transaction started.&lt;/p&gt;

&lt;p&gt;Applications using this level must be prepared to retry transactions due to serialization failures.
Note that only updating transactions might need to be retried; read-only transactions will never have serialization conflicts.&lt;/p&gt;

&lt;h2 id=&#34;serializable-isolation-level&#34;&gt;Serializable Isolation Level&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Serializable&lt;/code&gt; isolation level provides the strictest transaction isolation.
This level emulates serial transaction execution, as if transactions had been executed one after another, serially, rather than concurrently.
However, like the Repeatable Read level, applications using this level must be prepared to retry transactions due to serialization failures.&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;p&gt;More details can be taken here: &lt;a href=&#34;https://www.postgresql.org/docs/9.2/static/transaction-iso.html&#34;&gt;PostgreSQL Documentation. Chapter 13. Concurrency Control. 13.2. Transaction Isolation&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Transaction isolation levels</title>
      <link>http://iryndin.net/post/transaction_isolation_levels/</link>
      <pubDate>Tue, 28 Nov 2017 07:14:59 +0300</pubDate>
      
      <guid>http://iryndin.net/post/transaction_isolation_levels/</guid>
      <description>&lt;p&gt;Transaction isolation levels in relational databases. A reminder post.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;ansi-sql-standard-isolation-levels&#34;&gt;ANSI/SQL standard isolation levels&lt;/h2&gt;

&lt;p&gt;We have 4 standard-defined transaction isolation levels:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Read uncommited.&lt;/strong&gt; Dirty reads - YES, Non-Repeatable reads - YES, Phantom reads - YES.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Read commited.&lt;/strong&gt; Dirty reads - NO, Non-Repeatable reads - YES, Phantom reads - YES.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Repeatable read.&lt;/strong&gt; Dirty reads - NO, Non-Repeatable reads - NO, Phantom reads - YES.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Serializable.&lt;/strong&gt; Dirty reads - NO, Non-Repeatable reads - NO, Phantom reads - NO.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here &lt;code&gt;YES&lt;/code&gt; means &lt;code&gt;may occur&lt;/code&gt;, while &lt;code&gt;NO&lt;/code&gt; means &lt;code&gt;should not occur at all&lt;/code&gt;. So &lt;code&gt;NO&lt;/code&gt; here is more strong expression than &lt;code&gt;YES&lt;/code&gt;.
Different DBMS may make this &lt;code&gt;YES&lt;/code&gt; more restrictive. E.g. PostgreSQL does not allow &lt;code&gt;Phantom Reads&lt;/code&gt; on its &lt;code&gt;Repeatable read&lt;/code&gt; level.
See details here: &lt;a href=&#34;http://iryndin.net/post/postgresql_transaction_isolation_levels/&#34;&gt;PostgreSQL transaction isolation levels&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;read-phenomena&#34;&gt;Read phenomena&lt;/h2&gt;

&lt;p&gt;The ANSI/ISO standard SQL 92 refers to three different read phenomena when Transaction 1 reads data
that Transaction 2 might have changed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dirty reads&lt;/li&gt;
&lt;li&gt;Non-Repeatable reads&lt;/li&gt;
&lt;li&gt;Phantom reads&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s consider them. Let&amp;rsquo;s operate with following database table &lt;strong&gt;users&lt;/strong&gt; that has following data.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;age&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;John&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Eva&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;dirty-reads&#34;&gt;Dirty reads&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;dirty read&lt;/em&gt; (aka uncommitted dependency) occurs when a transaction is allowed to read data from a row
that has been modified by another running transaction and not yet committed.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Transaction 1&lt;/th&gt;
&lt;th&gt;Transaction 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/* Query 1. Will read 20*/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;select age from users where id=1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/* Query 2. No commit here. */&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;update users set age=50 where id=1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/* Query 1. Will read 50 */&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;select age from users where id=1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/* Lock-based dirty read. */&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;rollback&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We can see here that &lt;em&gt;dirty read&lt;/em&gt; will read age value of &lt;code&gt;50&lt;/code&gt; in the 2nd query, even if &lt;em&gt;Transaction 2&lt;/em&gt; will be rolled back afterwards.&lt;/p&gt;

&lt;h2 id=&#34;non-repeatable-reads&#34;&gt;Non-Repeatable reads&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;non-repeatable read&lt;/em&gt; occurs, when during the course of a transaction,
a row is retrieved twice and the values within the row differ between reads.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Transaction 1&lt;/th&gt;
&lt;th&gt;Transaction 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/* Query 1. */&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;select * from users where id=1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/* Query 2. */&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;update users set age = 50 where id = 1;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;commit;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/* Query 1. */&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;select * from users where id=1;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;commit;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;During &lt;em&gt;Transaction 1&lt;/em&gt; &lt;em&gt;Transaction 2&lt;/em&gt; is started and committed, and it changes rows that should be returned as a result
of &lt;em&gt;Transaction 1&lt;/em&gt;. But &lt;em&gt;Transaction 1&lt;/em&gt; has already seen the different value before &lt;em&gt;Transaction 2&lt;/em&gt; starts.
So what value should it return?&lt;/p&gt;

&lt;p&gt;If transaction isolation level is set to either to &lt;code&gt;Repeatable read&lt;/code&gt; or &lt;code&gt;Serializable&lt;/code&gt; (levels at which Non-Repeatable reads
do not occur) - then &lt;em&gt;Transaction 1&lt;/em&gt; should return old values (where age is 20).&lt;/p&gt;

&lt;p&gt;If transaction isolation level is set to either to &lt;code&gt;Read uncommited&lt;/code&gt; or &lt;code&gt;Read commited&lt;/code&gt; (levels at which Non-Repeatable reads
may occur) - then &lt;em&gt;Transaction 1&lt;/em&gt; may return new values (which incorporate changes made by &lt;em&gt;Transaction 2&lt;/em&gt;, i.e. where age is 20).&lt;/p&gt;

&lt;h2 id=&#34;phantom-reads&#34;&gt;Phantom reads&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;phantom read&lt;/em&gt; occurs when, in the course of a transaction, two identical queries are executed,
and the collection of rows returned by the second query is different from the first.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Transaction 1&lt;/th&gt;
&lt;th&gt;Transaction 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/* Query 1. */&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;select * from users&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;where age between 10 and 30;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/* Query 2. */&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;insert into users(id,name,age)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;values (3, &#39;Bob&#39;, 27); commit;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/* Query 1. */&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;select * from users&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;where age between 10 and 30;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;At the highest isolation level (&lt;code&gt;Serializable&lt;/code&gt;) &lt;em&gt;Transaction 1&lt;/em&gt; will return the same set of rows
(i.e. it will return 2 rows). While at lower transaction isolation levels (&lt;code&gt;Uncommited read&lt;/code&gt;, &lt;code&gt;Commited read&lt;/code&gt;, &lt;code&gt;Non-repeatable read&lt;/code&gt;)
it will return set of rows including those rows added with &lt;em&gt;Transaction 2&lt;/em&gt;, i.e. it will return 3 rows.&lt;/p&gt;

&lt;h2 id=&#34;jdbc&#34;&gt;JDBC&lt;/h2&gt;

&lt;p&gt;JDBC driver can have following transaction isolation levels:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Connection.TRANSACTION_NONE&lt;/code&gt; - a constant indicating that transactions are not supported&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connection.TRANSACTION_READ_UNCOMMITTED&lt;/code&gt; - read uncommited level&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connection.TRANSACTION_READ_COMMITTED&lt;/code&gt; - read commited level&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connection.TRANSACTION_REPEATABLE_READ&lt;/code&gt; - repeztable read level&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connection.TRANSACTION_SERIALIZABLE&lt;/code&gt; - serializable level&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See more details here: &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/sql/Connection.html&#34;&gt;java.sql.Connection&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>