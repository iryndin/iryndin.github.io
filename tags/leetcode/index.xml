<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Just my blog</title>
    <link>http://iryndin.net/tags/leetcode/index.xml</link>
    <description>Recent content in Leetcode on Just my blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://iryndin.net/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Leetcode 121. Best time to buy and sell stock</title>
      <link>http://iryndin.net/post/leetcode_121_best_time_to_buy_and_sell_stock/</link>
      <pubDate>Sat, 09 Jun 2018 12:19:43 +0000</pubDate>
      
      <guid>http://iryndin.net/post/leetcode_121_best_time_to_buy_and_sell_stock/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s condsider easy dynamic problem: best time to buy and sell stock.
This is &lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/&#34;&gt;Leetcode 121. Best Time to Buy and Sell Stock&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;Say you have an array for which the &lt;code&gt;i-th&lt;/code&gt; element is the price of a given stock on day i.&lt;/p&gt;

&lt;p&gt;If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;

&lt;p&gt;Note that you cannot sell a stock before you buy one.&lt;/p&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example 1&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;example-2&#34;&gt;Example 2&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;brute-force-solution&#34;&gt;Brute force solution&lt;/h2&gt;

&lt;p&gt;Without a lot of thinking we can come up with brute force solution.
We buy stock on some particular day, and then for the next days we check profit if we sell this stock. Thus we will find the maximum profit. Time complexity is &lt;code&gt;O(n^2)&lt;/code&gt;, while space complexity is &lt;code&gt;O(1)&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  public int maxProfit(int[] prices) {
    int result = 0;
    for (int i=0;i&amp;lt;prices.length-1;i++) {
      int maxProfit = maxProfit(prices, i);
      if (maxProfit &amp;gt; result) {
        result = maxProfit;
      }
    }
    return result;
  }

  // Calculate max profit is stock is bought on day idx
  // and sold on one of the next days
  static int maxProfit(int[] prices, int idx) {
    int diff = 0;
    for (int j=idx+1; j&amp;lt;prices.length; j++) {
      diff = Math.max(diff, prices[j]-prices[idx]);
    }
    return diff;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;more-smart-solution&#34;&gt;More smart solution&lt;/h2&gt;

&lt;p&gt;However, we can come up with more smart solution, that has time complexity only &lt;code&gt;O(n)&lt;/code&gt;,
i.e. only one array pass is required.&lt;/p&gt;

&lt;p&gt;Here is the idea. We got max profit when we buy on lowest price, and  sell on highest price.
So let&amp;rsquo;s track minimum price and max profit. Let&amp;rsquo;s traverse through price array,
and check profit and min price with every new array element. If we found new min price and
new max profit, then update our variables. Space complexity for this approach is &lt;code&gt;O(1)&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  public int maxProfit(int[] prices) {
    if (prices == null || prices.length &amp;lt; 2) {
      return 0;
    }
    int minPrice = Integer.MAX_VALUE-1;
    int maxProfit = 0;
    for (int i=0;i&amp;lt;prices.length;i++) {
      int todayProfit = prices[i] - minPrice;
      if (prices[i] &amp;lt; minPrice) 
        minPrice = prices[i];
      }
      if (todayProfit &amp;gt; maxProfit) {
        maxProfit = todayProfit;
      }
    }
    return maxProfit;
  }
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Leetcode 746. Min cost climbing stairs</title>
      <link>http://iryndin.net/post/leetcode_746_min_cost_climbing_stairs/</link>
      <pubDate>Sat, 09 Jun 2018 02:16:40 +0000</pubDate>
      
      <guid>http://iryndin.net/post/leetcode_746_min_cost_climbing_stairs/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s condsider another easy dynamic problem: minimal cost of climbing stairs.
This is &lt;a href=&#34;https://leetcode.com/problems/min-cost-climbing-stairs/description/&#34;&gt;Leetcode 746. Min Cost Climbing Stairs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;On a staircase, the &lt;code&gt;i-th&lt;/code&gt; step has some non-negative cost &lt;code&gt;cost[i]&lt;/code&gt; assigned (&lt;code&gt;0&lt;/code&gt; indexed).&lt;/p&gt;

&lt;p&gt;Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index &lt;code&gt;0&lt;/code&gt;, or the step with index &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example 1&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Input: cost = [10, 15, 20]
Output: 15
Explanation: Cheapest is start on cost[1], pay that cost and go to the top.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;example-2&#34;&gt;Example 2&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
Output: 6
Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cost&lt;/code&gt; will have a length in the range &lt;code&gt;[2, 1000]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;every &lt;code&gt;cost[i]&lt;/code&gt; will be an integer in the range &lt;code&gt;[0, 999]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;analysis&#34;&gt;Analysis&lt;/h2&gt;

&lt;p&gt;Once we can climb one or two steps, for &lt;code&gt;n-th&lt;/code&gt; stair the minimal cost will be minimal of two values:
cost for &lt;code&gt;n-1&lt;/code&gt; step and cost for &lt;code&gt;n-2&lt;/code&gt; stair. Or, recursively, this can be expressed as:&lt;br /&gt;
&lt;code&gt;minCost(n) = min(minCost(n-1),minCost(n-2))&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;recursive-solution&#34;&gt;Recursive solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  public int minCostClimbingStairs(int[] cost) {
    if (cost == null || cost.length == 0) return 0;
    else if (cost.length == 1) return cost[0];
    int LEN = cost.length;
    return Math.min(minCost(cost, LEN-1), minCost(cost, LEN-2));
  }

  // Calculate minimal cost to reach stair with index i (i is 0-based index)
  static int minCost(int[] cost, int i) {
    switch (i) {
      case 0: return cost[0];
      case 1: return cost[1];
      default: return cost[i] + Math.min(minCost(cost, i-1), minCost(cost, i-2));
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What is good for this solution, as with almost all recursive solutions, that it is concise and expressive. But for pretty long array it will take tons of time to complete. For Leetcode, this solution gets &lt;code&gt;TLE&lt;/code&gt; - &lt;code&gt;Time Limit Exception&lt;/code&gt;. So, let&amp;rsquo;s consider another solution.&lt;/p&gt;

&lt;h2 id=&#34;better-way&#34;&gt;Better way&lt;/h2&gt;

&lt;p&gt;Here is solution with &lt;code&gt;O(n)&lt;/code&gt; time complexity and &lt;code&gt;O(1)&lt;/code&gt; space complexity:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  public int minCostClimbingStairs(int[] cost) {
    if (cost == null || cost.length == 0) return 0;
    else if (cost.length == 1) return cost[0];
    int LEN = cost.length;
    int prevPrevStairMinCost = cost[0], prevStairMinCost = cost[1];
    int minCost = 0;
    for (int i=2; i&amp;lt;LEN; i++) {
      minCost = cost[i] + Math.min(prevStairMinCost, prevPrevStairMinCost);
      prevPrevStairMinCost = prevStairMinCost;
      prevStairMinCost = minCost;
    }
    return Math.min(prevStairMinCost, prevPrevStairMinCost);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;p&gt;See also &lt;a href=&#34;http://iryndin.net/post/leetcode_70_climbing_stairs/&#34;&gt;Leetcode 70. Climbing stairs&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Leetcode 70. Climbing stairs</title>
      <link>http://iryndin.net/post/leetcode_70_climbing_stairs/</link>
      <pubDate>Sat, 09 Jun 2018 01:49:55 +0000</pubDate>
      
      <guid>http://iryndin.net/post/leetcode_70_climbing_stairs/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s condsider easy dynamic problem: climbing stairs.
This is &lt;a href=&#34;https://leetcode.com/problems/climbing-stairs/description/&#34;&gt;Leetcode 70. Climbing stairs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;br /&gt;
Each time you can either climb 1 or 2 steps.&lt;br /&gt;
In how many distinct ways can you climb to the top?&lt;br /&gt;
Note: Given n will be a positive integer.&lt;/p&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example 1&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Input: 2  
Output: 2  
Explanation: There are two ways to climb to the top.  
1. 1 step + 1 step  
2. 2 steps  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;example-2&#34;&gt;Example 2&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;analysis&#34;&gt;Analysis&lt;/h2&gt;

&lt;p&gt;Number of distinct ways for each stair is a sum of number of distinct ways for previous stair and
number of distinct ways for previous-previous stair, recursively it can be expressed as following:&lt;br /&gt;
&lt;code&gt;ways(n)=ways(n-1) + ways(n-2)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;recursive-solution&#34;&gt;Recursive solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  public int climbStairs(int n) {
    switch(n) {
      case 0: return 0;
      case 1: return 1;
      case 2: return 2;
      default: return climbStairs(n-1) + climbStairs(n-2);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This recursive solution will do many repeating computations, but this is most clear and concise way
to express solution. Now let&amp;rsquo;s consider more economical approach.&lt;/p&gt;

&lt;h2 id=&#34;better-way&#34;&gt;Better way&lt;/h2&gt;

&lt;p&gt;This is better solution, with time complexity &lt;code&gt;O(n)&lt;/code&gt; and space complexity &lt;code&gt;O(1)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  public int climbStairs(int n) {
    if (n &amp;lt;= 2) return n;
    int prevPrevStair = 1, prevStair = 2;
    int curStair=0;
    for (int i=2; i&amp;lt;n; i++) {
      curStair = prevStair + prevPrevStair;
      prevPrevStair = prevStair;
      prevStair = curStair;
    }
    return curStair;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;h2 id=&#34;links-1&#34;&gt;Links&lt;/h2&gt;

&lt;p&gt;See also &lt;a href=&#34;http://iryndin.net/post/leetcode_746_min_cost_climbing_stairs/&#34;&gt;Leetcode 746. Minimal cost climbing stairs&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>