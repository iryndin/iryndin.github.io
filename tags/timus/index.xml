<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Timus on Just my blog</title>
    <link>http://iryndin.net/tags/timus/index.xml</link>
    <description>Recent content in Timus on Just my blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://iryndin.net/tags/timus/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Timus 1005. Stone pile</title>
      <link>http://iryndin.net/post/timus-1005-stone-pile/</link>
      <pubDate>Mon, 17 Apr 2017 11:38:06 +0300</pubDate>
      
      <guid>http://iryndin.net/post/timus-1005-stone-pile/</guid>
      <description>

&lt;p&gt;This is a first post which describes how to solve some particular programming task. Today we will consider
&lt;a href=&#34;http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1005&#34;&gt;Stone pile&lt;/a&gt; task from &lt;a href=&#34;http://acm.timus.ru/&#34;&gt;Timus&lt;/a&gt;.
It is clear and easy. The task sounds like:&lt;/p&gt;

&lt;h1 id=&#34;task&#34;&gt;Task&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1005&#34;&gt;Stone pile&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;task-1&#34;&gt;Task&lt;/h2&gt;

&lt;p&gt;You have a number of stones with known weights w&lt;sub&gt;1&lt;/sub&gt;, …, w&lt;sub&gt;n&lt;/sub&gt;.
Write a program that will rearrange the stones into two piles
such that weight difference between the piles is minimal.&lt;/p&gt;

&lt;h2 id=&#34;input&#34;&gt;Input&lt;/h2&gt;

&lt;p&gt;Input contains the number of stones n (1 ≤ n ≤ 20) and weights of the stones w&lt;sub&gt;1&lt;/sub&gt;, …, w&lt;sub&gt;n&lt;/sub&gt;
(integers, 1 ≤ w&lt;sub&gt;i&lt;/sub&gt; ≤ 100000) delimited by white spaces.&lt;/p&gt;

&lt;h2 id=&#34;output&#34;&gt;Output&lt;/h2&gt;

&lt;p&gt;Your program should output a number representing the minimal possible weight difference between stone piles.&lt;/p&gt;

&lt;h2 id=&#34;limits&#34;&gt;Limits&lt;/h2&gt;

&lt;p&gt;Time limit: 1.0 second&lt;/p&gt;

&lt;p&gt;Memory limit: 64 MB&lt;/p&gt;

&lt;h1 id=&#34;solution&#34;&gt;Solution&lt;/h1&gt;

&lt;p&gt;The easiest approach is to check all possible stone pile variants and to test which one has minimal weight difference.
I.e. this is &lt;code&gt;brute force&lt;/code&gt; approach.&lt;/p&gt;

&lt;p&gt;How can we generate all these variants? So, we have 2 piles - first and second.
Let&amp;rsquo;s designate that stone is in the first pile with value &lt;code&gt;0&lt;/code&gt;, and that stone is in the second pile with value &lt;code&gt;1&lt;/code&gt;.
Let&amp;rsquo;s imagine that we have 3 stones, so let&amp;rsquo;s generate all possible stone placements in 2 piles:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0 0 0 (all 3 stones (w&lt;sub&gt;1&lt;/sub&gt;, w&lt;sub&gt;2&lt;/sub&gt;, w&lt;sub&gt;3&lt;/sub&gt;)are in the first pile)&lt;/li&gt;
&lt;li&gt;0 0 1 (w&lt;sub&gt;1&lt;/sub&gt;, w&lt;sub&gt;2&lt;/sub&gt; are in 1st pile, w&lt;sub&gt;3&lt;/sub&gt; is in the 2nd pile)&lt;/li&gt;
&lt;li&gt;0 1 0 (w&lt;sub&gt;1&lt;/sub&gt;, w&lt;sub&gt;3&lt;/sub&gt; are in 1st pile, w&lt;sub&gt;2&lt;/sub&gt; is in the 2nd pile)&lt;/li&gt;
&lt;li&gt;0 1 1 (etc&amp;hellip;)&lt;/li&gt;
&lt;li&gt;1 0 0&lt;/li&gt;
&lt;li&gt;1 0 1&lt;/li&gt;
&lt;li&gt;1 1 0&lt;/li&gt;
&lt;li&gt;1 1 1 (all 3 stones (w&lt;sub&gt;1&lt;/sub&gt;, w&lt;sub&gt;2&lt;/sub&gt;, w&lt;sub&gt;3&lt;/sub&gt;)are in the 2nd pile)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also we can see that regarding the weight difference first 4 variants are identical to the next 4 variants of stone
placements. This means that is it sufficient to check only half of all possible stone placements, i.e. &lt;code&gt;n/2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Also we can see that stone placements are bit sequences. So all possible placements will be 2&lt;sup&gt;n&lt;/sup&gt;.
But since we can check only half of them, then we need to check only 2&lt;sup&gt;n-1&lt;/sup&gt; placements.
In Java/C++ it will be equal to &lt;code&gt;1 &amp;lt;&amp;lt; n-1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, summarizing all that, we will have following algorithm:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read input values&lt;/li&gt;
&lt;li&gt;Generate maximum number of variants we want to check: &lt;code&gt;LIMIT = 1 &amp;lt;&amp;lt; n-1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Loop from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;LIMIT&lt;/code&gt;, incrementing by &lt;code&gt;1&lt;/code&gt; on each loop cycle. Loop variable designates a particular placement variant.&lt;/li&gt;
&lt;li&gt;In each loop generate weight sum for each stone pile regarding bit order in the loop variable and check if this placement generates minimal weight difference.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;solution-code&#34;&gt;Solution code&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.*;
import java.util.*;

public class Timus1005
{
   public static void main(String[] args)
   {
      Scanner scanner = new Scanner(System.in);
      
      int n = scanner.nextInt();
      int[] stones = new int[n];
      
      for (int i=0; i&amp;lt;n; i++) {
          stones[i] = scanner.nextInt();
      }
      
      int diff = bruteForce(stones);
      
      PrintWriter out = new PrintWriter(System.out);
      out.println(diff);
      out.flush();
   }
   
   static int bruteForce(int[] stones) {
       final int N = stones.length;
       final int LIMIT = 1 &amp;lt;&amp;lt; N-1;
       int diff = Integer.MAX_VALUE;
       
       for (int i=0; i&amp;lt;=LIMIT; i++) {
           int sum1=0, sum2=0;
           int k=i;
           for (int j=0; j&amp;lt;N; j++) {
               if ((k &amp;amp; 0x1) == 0) sum1+=stones[j];
               else sum2+=stones[j];
               k = k&amp;gt;&amp;gt;1;
           }
           int diffi = (sum1&amp;gt;=sum2) ? sum1-sum2 : sum2-sum1;
           if (diffi&amp;lt;diff) diff = diffi;
       }
       return diff;
   }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>