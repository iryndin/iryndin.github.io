<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Structures on Just my blog</title>
    <link>http://iryndin.net/tags/data-structures/index.xml</link>
    <description>Recent content in Data Structures on Just my blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://iryndin.net/tags/data-structures/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Trie or Prefix Tree</title>
      <link>http://iryndin.net/post/trie/</link>
      <pubDate>Thu, 28 Jun 2018 03:20:39 +0000</pubDate>
      
      <guid>http://iryndin.net/post/trie/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s consider another popular data structure: Trie or Prefix tree.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Trie (or prefix tree) is an ordered tree data structure, mainly used for operations with strings (but now always). If we consider strings, then for trie following points are true:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nodes can have multiple children&lt;/li&gt;
&lt;li&gt;Key is not stored in the node, rather it is defined by node position in the tree&lt;/li&gt;
&lt;li&gt;Each node stores single character&lt;/li&gt;
&lt;li&gt;Prefix is defined as a sequence of characters by traversing trie from root down to particular node. Hence, all children of a node have the common prefix.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Codewise, node of a trie can be defines as this (please note that there is no &lt;code&gt;key&lt;/code&gt; in the node!):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class TrieNode&amp;lt;T&amp;gt; {
  T value;
  Map&amp;lt;Character, TrieNode&amp;gt; children;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or another common representation is to have array (with size equal to alphabet length) where non-null array members are children of this node.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class TrieNode {
  T value;
  TrieNode[] children = new TrieNode[26];

  /**
   * Get child for character {@code c}
   **/
  public TrieNode getChild(char c) {
    int idx = (int)&#39;a&#39; - (int)c;
    return children[idx];
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example of storing dictionary (&lt;code&gt;sam, sand, sir, sick, sunday&lt;/code&gt;) in trie:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://iryndin.net/img/trie.png&#34; style=&#34;width:50%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;usage-of-trie&#34;&gt;Usage of trie&lt;/h2&gt;

&lt;p&gt;Trie can be used for following tasks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dictionary representation&lt;/li&gt;
&lt;li&gt;autocomplete feature in text editors&lt;/li&gt;
&lt;li&gt;searching for common prefix&lt;/li&gt;
&lt;li&gt;it is used in some algorithms: Aho-Corasick, Lempel-Ziv-Welch compression algorithm&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;operations-on-the-trie&#34;&gt;Operations on the trie&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s deal with first implementation of &lt;code&gt;TrieNode&lt;/code&gt;,
i.e. where chidren are put into map: &lt;code&gt;Map&amp;lt;Character, TrieNode&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;look-for-a-key&#34;&gt;Look for a key&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;T&amp;gt; T find(String key, TrieNode&amp;lt;T&amp;gt; root) {
  TrieNode&amp;lt;T&amp;gt; cur = root;
  for (char c : key.toCharArray()) {
    TrieNode&amp;lt;T&amp;gt; n = cur.children == null ? null : cur.children.get(c);
    if (n != null) {
      cur = n;
    } else {
      return null;
    }
  }
  return cur.value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;insert-key&#34;&gt;Insert key&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Return previous value associated with key, 
// or null if no previous value was associated
&amp;lt;T&amp;gt; T insert(String key, T newValue, TrieNode&amp;lt;T&amp;gt; root) {
  TrieNode&amp;lt;T&amp;gt; cur = root;
  for (int i=0; i&amp;lt;key.length(); i++) {
    char c = key.charAt(i);
    TrieNode&amp;lt;T&amp;gt; n = cur.children == null ? null : cur.children.get(c);
    if (n != null) {
      cur = n;
    } else {
      if (cur.children == null) {
        cur.children = new HashMap&amp;lt;&amp;gt;();
      }
      TrieNode&amp;lt;T&amp;gt; newNode = new TrieNode&amp;lt;&amp;gt;();
      cur.children.put(c, newNode);
      cur = newNode;
    }
  }
  T oldValue = cur.value;
  cur.value = value;
  return oldValue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;remove-key&#34;&gt;Remove key&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;T&amp;gt; T delete(String key, TrieNode&amp;lt;T&amp;gt; root) {
  TrieNode&amp;lt;T&amp;gt; cur = root;
  for (char c : key.toCharArray()) {
    TrieNode&amp;lt;T&amp;gt; n = cur.children == null ? null : cur.children.get(c);
    if (n != null) {
      cur = n;
    } else {
      return null;
    }
  }  
  T oldValue = cur.value;
  cur.value = null;
  return oldValue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/tag/trie/&#34;&gt;Leetcode - Problems for tries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/tag/trie/&#34;&gt;GeekForGeeks - Trie articles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://practice.geeksforgeeks.org/topics/Trie&#34;&gt;GeekForGeeks - Trie practice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/basecs/trying-to-understand-tries-3ec6bede0014&#34;&gt;Basecs - Trying to understand tries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hackerearth.com/practice/data-structures/advanced-data-structures/trie-keyword-tree/tutorial/&#34;&gt;Hackerearth - Trie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.baeldung.com/trie-java&#34;&gt;Baeldung - The Trie Data Structure in Java&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Binary search tree</title>
      <link>http://iryndin.net/post/binary_search_tree/</link>
      <pubDate>Sun, 17 Jun 2018 02:55:26 +0000</pubDate>
      
      <guid>http://iryndin.net/post/binary_search_tree/</guid>
      <description>&lt;p&gt;Binary search tree (BST) is a data structure that allows fast element lookup, addition or removal of items.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;It is a binary tree that has following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the left subtree of a node contains only nodes with keys lesser than the node’s key&lt;/li&gt;
&lt;li&gt;the right subtree of a node contains only nodes with keys greater than the node’s key&lt;/li&gt;
&lt;li&gt;the left and right subtree each must also be a binary search tree. There must be no duplicate nodes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://iryndin.net/img/binary_search_tree.png&#34; style=&#34;width:100%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;node-class&#34;&gt;Node class&lt;/h2&gt;

&lt;p&gt;Let BST node be described with following class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Node {
  public int key;
  public int val;
  public Node left;
  public Node right;

  public Node(int key, int val) {
    this.key = key;
    this.val = val;
    this.left = this.right = null;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;search&#34;&gt;Search&lt;/h2&gt;

&lt;p&gt;Searching for a key in a BST can be done either recursively or iteratively.
Complexity is, of course, &lt;code&gt;O(log(n))&lt;/code&gt; on average.
But for worst case (when BST degrades to linked list) comlexity can degrade to &lt;code&gt;O(n)&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;recursive-search&#34;&gt;Recursive search&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Node search(Node root, int key) {
  if (root == null || root.key == key) {
  	return root;
  }
  if (key &amp;lt; root.key) return search(root.left, key);
  else return search(root.right, key);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;iterative-search&#34;&gt;Iterative search&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Node search(Node root, int key) {
  Node current = root;
  while (current != null) {
    if (current.key == key) return current;
    if (key &amp;lt; current.key) current = current.left;
    else current = current.right;
  }
  return current;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;insert-new-key&#34;&gt;Insert new key&lt;/h2&gt;

&lt;p&gt;Inserting new key is similar to search. We always start from root, and then traverse down to leaf nodes.
So, that new values are always inserted as leaf nodes.
This means that BST structure depends on the order in which new keys are inserted.&lt;/p&gt;

&lt;h3 id=&#34;recursive-insert&#34;&gt;Recursive insert&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Node insert(Node root, int key, int val) {
  if (root == null) {
    // when tree is empty, create new root
    return new Node(key, val);
  } else if (key == root.key) {
    root.val = val;
  } else if (key &amp;lt; root.key) {
    root.left = insert(root.left, key, val);
  } else {
    root.right = insert(root.right, key, val);
  }
  return root;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;iterative-insert&#34;&gt;Iterative insert&lt;/h3&gt;

&lt;p&gt;When implementing iterative insert we should also track the parent of the current node.
We need this parent to link one of its children (left or right) to a newly created leaf node.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Node insert(Node root, int key, int val) {
  Node parent = null;
  Node current = root;
  while (true) {
    if (current == null) {
      current = new Node(key, val);
      if (parent != null) {
        if (key &amp;lt; parent.key) parent.left = current;
        else parent.right = current;
      }
      break;
  	}
    if (key == current.key) {
      current.val = val;
      break;
    }
    parent = current;
    if (key &amp;lt; current.key) {
      current = current.left;
    } else {
      current = current.right;
    }
  }
  return current;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;delete-key&#34;&gt;Delete key&lt;/h2&gt;

&lt;p&gt;When removing node from BST, it is mandatory to maintain in-order sequence of nodes.
Let&amp;rsquo;s consider following cases when deleting a node:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it is leaf node, i.e. it does not have children. In this case simply remove the node&lt;/li&gt;
&lt;li&gt;node has only one child. In this case simply remove this node, and put a child in its place.&lt;/li&gt;
&lt;li&gt;node has left and right children&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So far let&amp;rsquo;s write code that process deletion of a given key from BST for first two cases
(i.e. when node either does not have children or has only one child):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// remove key and return new root of the BST
Node delete(Node root, int key) {
  if (root == null) {
    return null;
  }
  if (key &amp;lt; root.key) {
    root.left = delete(root.left, key);
  } else if (key &amp;gt; root.key) {
    root.right = delete(root.right, key);
  } else {
    // here root.key == key
    if (root.right == null) {
      return root.left;
    } else if (root.left == null) {
      return root.right;
    } else {
      // Complex case: node has 2 children
      // Discuss it further. 
      deleteNodeWith2Children(root, key);
    }
  }
  return root;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;delete-using-in-order-successors-approach&#34;&gt;Delete using in-order successors approach&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s consider case when node has 2 non-null children: &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;.
We find in-order successor (node with the next smallest key) of the current node,
and put its value in-place of the current node. Then we simply delete this successor node.
So, the code is as following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void deleteNodeWith2Children(Node root, int key) {
  assert root.key == key;
  assert root.left != null;
  assert root.right != null;

  Node successor = findSuccessor(root.right);
  root.key = successor.key;
  root.val = successor.val;
  root.right = delete(root.right, successor.key);
}

// Find most minimal node, 
// so go left as far as possible
Node findSuccessor(Node root) {
  Node cur = root;
  while (cur.left != null) {
    cur = cur.left; 
  }
  return cur;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;delete-using-in-order-predecessor-approach&#34;&gt;Delete using in-order predecessor approach&lt;/h3&gt;

&lt;p&gt;Here approach is the same as with in-order successor.
We find in-order predecessor of current node, and put its key and value in place of current node.
Then we simply delete the predecessor node.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void deleteNodeWith2Children(Node root, int key) {
  assert root.key == key;
  assert root.left != null;
  assert root.right != null;

  Node predecessor = findPredecessor(root.left);
  root.key = predecessor.key;
  root.val = predecessor.val;
  root.left = delete(root.left, predecessor.key);
}

// Find node with max key,
// so go right as far as possible
Node findPredecessor(Node root) {
  Node cur = root;
  while (cur.right != null) {
    cur = cur.right; 
  }
  return cur;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;notes-on-using-either-in-order-successor-or-predecessor&#34;&gt;Notes on using either in-order successor or predecessor&lt;/h3&gt;

&lt;p&gt;Consistently using the in-order successor or the in-order predecessor for every instance of the two-child case can lead to an unbalanced tree, so some implementations select one or the other at different times.&lt;/p&gt;

&lt;h2 id=&#34;tree-traversals&#34;&gt;Tree traversals&lt;/h2&gt;

&lt;p&gt;Next depth-first-search traversals exist:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;in-order traversal (Left, Root, Right)&lt;/li&gt;
&lt;li&gt;pre-order traversal (Root, Left, Right)&lt;/li&gt;
&lt;li&gt;post-order traversal (Left, Right, Root)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;in-order-traversal&#34;&gt;In-order traversal&lt;/h3&gt;

&lt;p&gt;In-order traversal: we visit nodes in the following order: Left -&amp;gt; Root -&amp;gt; Right.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void traverseInOrder(Node root) {
  if (root != null) {
    traverseInOrder(root.left);
    System.out.println(root.key);
    traverseInOrder(root.right);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pre-order-traversal&#34;&gt;Pre-order traversal&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void traversePreOrder(Node root) {
  if (root != null) {
    System.out.println(root.key);
    traverseInOrder(root.left);    
    traverseInOrder(root.right);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;post-order-traversal&#34;&gt;Post-order traversal&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void traversePreOrder(Node root) {
  if (root != null) {    
    traverseInOrder(root.left);    
    traverseInOrder(root.right);
    System.out.println(root.key);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;verify-that-binary-search-tree-is-correct&#34;&gt;Verify that Binary Search Tree is correct&lt;/h2&gt;

&lt;p&gt;Here is a small task: verify that given BST is correct.  Lower given an example with incorrect BST:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     20
    /  \
  10    30
       /  \
      5    40
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node with key &lt;code&gt;5&lt;/code&gt; should be greater than &lt;code&gt;20&lt;/code&gt;, hence it is not a valid BST.&lt;/p&gt;

&lt;p&gt;So we should track not only value of parent, but minimum and maximum values as well.
We should check that node key is between max and min value.&lt;br /&gt;
If we go down left branch, we should update &lt;code&gt;maxKey&lt;/code&gt;,
because left branch in BST should contain nodes with smaller keys.&lt;br /&gt;
If we go right branch, we should update &lt;code&gt;minKey&lt;/code&gt;, because right branch contains&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;boolean isCorrect(Node root) {
  if (root == null) return true;
  return isCorrect(root, Integer.MIN_VALUE, INTEGER.MAX_VALUE);
}

boolean isCorrect(Node root, int minKey, int maxKey) {
  if (root == null) return true;
  if (root.key &amp;lt;= minKey || root.key &amp;gt;= maxKey) return false;
  return 
    isCorrect(root.left, minKey, root.key) &amp;amp;&amp;amp;
    isCorrect(root.right, root.key, maxKey);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;find-max-and-min-elements-in-bst&#34;&gt;Find max and min elements in BST&lt;/h2&gt;

&lt;p&gt;Minimal element in the BST is the leftmost element:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Node findMin(Node root) {
  if (root == null) return null;
  Node cur = root;
  while (cur.left != null) {
  	cur = cur.left;
  }
  return cur;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The largest lement in the BST in rightmost element.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Node findMax(Node root) {
  if (root == null) return null;
  Node cur = root;
  while (cur.right != null) {
  	cur = cur.right;
  }
  return cur;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search_tree&#34;&gt;Wikipedia article on Binary Search Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/&#34;&gt;GeeksForGeeks - Binary Search Tree | Set 1 (Search and Insertion)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/&#34;&gt;GeeksForGeeks - Tree Traversals (Inorder, Preorder and Postorder)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/binary-search-tree-data-structure/&#34;&gt;GeeksForGeeks - All articles on BST&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/category/binary-search-tree/&#34;&gt;GeeksForGeeks - All articles tagged with BST tag&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/tag/binary-search-tree/&#34;&gt;Leetcode - Problems for BST&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/tag/tree/&#34;&gt;Leetcode - Problems for Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>