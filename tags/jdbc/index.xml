<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jdbc on Just my blog</title>
    <link>http://iryndin.net/tags/jdbc/index.xml</link>
    <description>Recent content in Jdbc on Just my blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://iryndin.net/tags/jdbc/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Transaction isolation levels</title>
      <link>http://iryndin.net/post/transaction_isolation_levels/</link>
      <pubDate>Tue, 28 Nov 2017 07:14:59 +0300</pubDate>
      
      <guid>http://iryndin.net/post/transaction_isolation_levels/</guid>
      <description>&lt;p&gt;Transaction isolation levels in relational databases. A reminder post.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;ansi-sql-standard-isolation-levels&#34;&gt;ANSI/SQL standard isolation levels&lt;/h2&gt;

&lt;p&gt;We have 4 standard-defined transaction isolation levels:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Read uncommited.&lt;/strong&gt; Dirty reads - YES, Non-Repeatable reads - YES, Phantom reads - YES.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Read commited.&lt;/strong&gt; Dirty reads - NO, Non-Repeatable reads - YES, Phantom reads - YES.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Repeatable read.&lt;/strong&gt; Dirty reads - NO, Non-Repeatable reads - NO, Phantom reads - YES.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Serializable.&lt;/strong&gt; Dirty reads - NO, Non-Repeatable reads - NO, Phantom reads - NO.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here &lt;code&gt;YES&lt;/code&gt; means &lt;code&gt;may occur&lt;/code&gt;, while &lt;code&gt;NO&lt;/code&gt; means &lt;code&gt;should not occur at all&lt;/code&gt;. So &lt;code&gt;NO&lt;/code&gt; here is more strong expression than &lt;code&gt;YES&lt;/code&gt;.
Different DBMS may make this &lt;code&gt;YES&lt;/code&gt; more restrictive. E.g. PostgreSQL does not allow &lt;code&gt;Phantom Reads&lt;/code&gt; on its &lt;code&gt;Repeatable read&lt;/code&gt; level.
See details here: &lt;a href=&#34;http://iryndin.net/post/postgresql_transaction_isolation_levels/&#34;&gt;PostgreSQL transaction isolation levels&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;read-phenomena&#34;&gt;Read phenomena&lt;/h2&gt;

&lt;p&gt;The ANSI/ISO standard SQL 92 refers to three different read phenomena when Transaction 1 reads data
that Transaction 2 might have changed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dirty reads&lt;/li&gt;
&lt;li&gt;Non-Repeatable reads&lt;/li&gt;
&lt;li&gt;Phantom reads&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s consider them. Let&amp;rsquo;s operate with following database table &lt;strong&gt;users&lt;/strong&gt; that has following data.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;age&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;John&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Eva&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;dirty-reads&#34;&gt;Dirty reads&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;dirty read&lt;/em&gt; (aka uncommitted dependency) occurs when a transaction is allowed to read data from a row
that has been modified by another running transaction and not yet committed.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Transaction 1&lt;/th&gt;
&lt;th&gt;Transaction 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/* Query 1. Will read 20*/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;select age from users where id=1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/* Query 2. No commit here. */&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;update users set age=50 where id=1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/* Query 1. Will read 50 */&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;select age from users where id=1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/* Lock-based dirty read. */&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;rollback&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We can see here that &lt;em&gt;dirty read&lt;/em&gt; will read age value of &lt;code&gt;50&lt;/code&gt; in the 2nd query, even if &lt;em&gt;Transaction 2&lt;/em&gt; will be rolled back afterwards.&lt;/p&gt;

&lt;h2 id=&#34;non-repeatable-reads&#34;&gt;Non-Repeatable reads&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;non-repeatable read&lt;/em&gt; occurs, when during the course of a transaction,
a row is retrieved twice and the values within the row differ between reads.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Transaction 1&lt;/th&gt;
&lt;th&gt;Transaction 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/* Query 1. */&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;select * from users where id=1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/* Query 2. */&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;update users set age = 50 where id = 1;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;commit;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/* Query 1. */&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;select * from users where id=1;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;commit;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;During &lt;em&gt;Transaction 1&lt;/em&gt; &lt;em&gt;Transaction 2&lt;/em&gt; is started and committed, and it changes rows that should be returned as a result
of &lt;em&gt;Transaction 1&lt;/em&gt;. But &lt;em&gt;Transaction 1&lt;/em&gt; has already seen the different value before &lt;em&gt;Transaction 2&lt;/em&gt; starts.
So what value should it return?&lt;/p&gt;

&lt;p&gt;If transaction isolation level is set to either to &lt;code&gt;Repeatable read&lt;/code&gt; or &lt;code&gt;Serializable&lt;/code&gt; (levels at which Non-Repeatable reads
do not occur) - then &lt;em&gt;Transaction 1&lt;/em&gt; should return old values (where age is 20).&lt;/p&gt;

&lt;p&gt;If transaction isolation level is set to either to &lt;code&gt;Read uncommited&lt;/code&gt; or &lt;code&gt;Read commited&lt;/code&gt; (levels at which Non-Repeatable reads
may occur) - then &lt;em&gt;Transaction 1&lt;/em&gt; may return new values (which incorporate changes made by &lt;em&gt;Transaction 2&lt;/em&gt;, i.e. where age is 20).&lt;/p&gt;

&lt;h2 id=&#34;phantom-reads&#34;&gt;Phantom reads&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;phantom read&lt;/em&gt; occurs when, in the course of a transaction, two identical queries are executed,
and the collection of rows returned by the second query is different from the first.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Transaction 1&lt;/th&gt;
&lt;th&gt;Transaction 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/* Query 1. */&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;select * from users&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;where age between 10 and 30;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/* Query 2. */&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;insert into users(id,name,age)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;values (3, &#39;Bob&#39;, 27); commit;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/* Query 1. */&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;select * from users&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;where age between 10 and 30;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;At the highest isolation level (&lt;code&gt;Serializable&lt;/code&gt;) &lt;em&gt;Transaction 1&lt;/em&gt; will return the same set of rows
(i.e. it will return 2 rows). While at lower transaction isolation levels (&lt;code&gt;Uncommited read&lt;/code&gt;, &lt;code&gt;Commited read&lt;/code&gt;, &lt;code&gt;Non-repeatable read&lt;/code&gt;)
it will return set of rows including those rows added with &lt;em&gt;Transaction 2&lt;/em&gt;, i.e. it will return 3 rows.&lt;/p&gt;

&lt;h2 id=&#34;jdbc&#34;&gt;JDBC&lt;/h2&gt;

&lt;p&gt;JDBC driver can have following transaction isolation levels:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Connection.TRANSACTION_NONE&lt;/code&gt; - a constant indicating that transactions are not supported&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connection.TRANSACTION_READ_UNCOMMITTED&lt;/code&gt; - read uncommited level&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connection.TRANSACTION_READ_COMMITTED&lt;/code&gt; - read commited level&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connection.TRANSACTION_REPEATABLE_READ&lt;/code&gt; - repeztable read level&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connection.TRANSACTION_SERIALIZABLE&lt;/code&gt; - serializable level&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See more details here: &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/sql/Connection.html&#34;&gt;java.sql.Connection&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>